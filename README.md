# Парсер товаров магазинов Metro и Ашан

Metro - работает только с помощью запросов, вытянутых из API, без Selenium, создается сессия, имитирующая пользователя.
Auchan - просто отправляются запросы (запрос тоже из API)

PoC в файле [./main.py](../main/main.py)

Данные:
* [Москва Метро "чай"](../main/data/Мск_метро_чай.csv)
* [Санкт-Петербург Метро "чай"](../main/data/Питер_метро_чай.csv)
* [Москва Ашан "посуда для приготовления"](../main/data/Мск_ашан_посуда.csv)
* [Санкт-Петербург Ашан "посуда для приготовления"](../main/data/Питер_ашан_посуда.csv)

Цены в копейках, что бы не хранить float

Для сохранения данных, используются классы в виде сырых объектов, для продукта и бренда (не стал выносить цены с городом в другую таблицу, что конечно же лучше).

Преимущества таких классов:
* может быть ключем словаря, т.е. можно найти ORM модель в словаре, где ключ - сырая модель, значение - ORM модель 
* можно легко найти уникальные значения за счет set([список классов])
* предыдущий пункт позволяет легко вычитать одни кортежи из других, например: все - новые, все - измененные, новые + измененные, и т.д.
* упрощается сравнение модели ORM и этого класса (\_\_eq\_\_)
* предыдущий пункт позволяет легко проверить, есть ли в **списке** ORM моделей (возможно, уже существующих) искомый сырой элемент
* гораздо меньше кода для создания новой модели, за счет маленькой функции to_dict()
* благодаря предыдущим шагам, шанс наткнуться на момент, когда ORM модель была создана, но не была записана - минимизируется (SQLAlchemy ругается на такое)
