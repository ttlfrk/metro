# Парсер товаров магазина Metro

Работает только с помощью запросов, вытянутых из API, без Selenium, создается сессия, имитирующая пользователя.

PoC в файле [./main.py](../main/main.py)

Готовые данные категории "чай" в файлах [./data/Питер_чай.csv](../main/data/Питер_чай.csv) и [./data/Мск_чай.csv](../main/data/Мск_чай.csv) цены в копейках (что бы не хранить float)

Изначально сделал просто сравнение словарей, где ключ - id товара/бренда,
но потом заметил, что нужны данные не для одного, а для двух городов, и сделал, как я обычно делаю, добавил "костыль" в виде классов для сырых объектов продукта и бренда (не стал выносить цены с городом в другую таблицу, что конечно же лучше).

Преимущества таких классов:
* может быть ключем словаря, т.е. можно найти ORM модель в словаре, где ключ - сырая модель, значение - ORM модель 
* можно легко найти уникальные значения за счет set([список классов])
* предыдущий пункт позволяет легко вычитать одни кортежи из других, например: все - новые, все - измененные, новые + измененные, и т.д.
* упрощается сравнение модели ORM и этого класса (__eq__)
* предыдущий пункт позволяет легко проверить, есть ли в **списке** ORM моделей (возможно, уже существующих) искомый сырой элемент
* гораздо меньше кода для создания новой модели, за счет маленькой функции to_dict()
* благодаря предыдущим шагам, шанс наткнуться на момент, когда ORM модель была создана, но не была записана - минимизируется (SQLAlchemy ругается на такое)
